#!/usr/bin/env perl
use strict;
use warnings;

#-------------------------------------------------------------------
# libraries

use Data::Dumper;
use Getopt::Long;
use FindBin;
use lib "$FindBin::RealBin/../perl5";
use MDU;
use MDU::Logger qw(msg err);
use List::Util qw(sum);

#-------------------------------------------------------------------
# command line

my $verbose = 0;
my $db_file = $MDU::MDUDIR."/../QC/QC.tab";
my $logical_or = 0;
my $csv = 0;
my($species, $scheme, $seqtype, $isolate, $date, $amr, $sero, $allele, $asm);

sub usage {
  my $EXE = $FindBin::RealScript;
  print <<"USAGE";
Synopsis:
  Query the MDU WGS database
Usage: 
  $EXE [options] 
Options:
  --help	This help
  --verbose	Extra debugging output ($verbose)
  --csv	        Write CSV instead of TSV/TAB
  --db FILE     CSV of isolate data ($db_file)
  --or          Do logical OR instead of AND
  --species P   Match SPECIES 
  --st      X   Match ST
  --allele  G   Match ST Alleles
  --scheme  P   Match SCHEME
  --id      P   Match ISOLATE
  --date    P   Match ANALYSIS_DATE
  --amr     G   Match AMR_GENES
  --sero    G   Match SEROTYPE
  --asm     A   Match ASSEMBLER
USAGE
  exit;
}

GetOptions(
  "help"      => \&usage,
  "verbose"   => \$verbose,
  "db=s"      => \$db_file,
  "csv"       => \$csv,
  "or"        => \$logical_or,
  "species=s" => \$species,
  "st=s"      => \$seqtype,
  "scheme=s"  => \$scheme,
  "id=s"      => \$isolate,
  "date=s"    => \$date,
  "amr=s"     => \$amr,
  "sero=s"    => \$sero,
  "allele=s"  => \$allele,
  "asm=s"     => \$asm,
) 
or usage();

#-------------------------------------------------------------------
# main script

if (@ARGV == 0) {
  exit( ! system("cat \Q$db_file\E") );
}

my %db;
msg("Opening database: $db_file");
open TSV, '<', $db_file;
my $header = <TSV>;
my(@hdr) = split m/\t/, $header;
chomp @hdr;
while (my $line = <TSV>) {
  chomp $line;
  my @x = split m/\t/, $line;
  for my $i (0 .. $#x) {
    $db { $x[0] } { $hdr[$i] } = $x[$i];
  }
  $line = tab_to_csv($line) if $csv;
  $db{$x[0]}{LINE} = $line;
}
close TSV;
msg("Read", scalar(keys %db), "isolates.");

my $pass = sum( map { $_ ? 1 : 0 } ($species, $seqtype, $sero, $scheme, $isolate, $date, $amr, $allele, $asm) );
$pass = 1 if $logical_or and $pass >= 1;
$pass ||= 1E9;
my @match;
for my $id (keys %db) {
  my $score=0;
  $score++ if $species and $db{$id}{SPECIES}       =~ m/$species/i;
  $score++ if $scheme  and $db{$id}{SCHEME}        =~ m/$scheme/i;
  $score++ if $seqtype and $db{$id}{ST}            eq $seqtype;
  $score++ if $allele  and $db{$id}{MLST_ALLELES}  =~ m/$allele/i;
  $score++ if $isolate and $db{$id}{ISOLATE}       =~ m/$isolate/i;
  $score++ if $date    and $db{$id}{ANALYSIS_DATE} =~ m/$date/;
  $score++ if $amr     and $db{$id}{AMR_GENES}     =~ m/$amr/i;
  $score++ if $sero    and $db{$id}{SEROTYPE}      =~ m/$sero/i;
  $score++ if $asm     and $db{$id}{ASSEMBLER}     =~ m/$asm/i;
  push @match, $db{$id}{LINE} if $score >= $pass;
}
msg("Found", 0+@match, "matches");
$header = tab_to_csv($header) if $csv;
print $header, map { "$_\n" } @match if @match > 0;

#-------------------------------------------------------------------

sub tab_to_csv {
  my($line) = @_;
  $line =~ s/,/~/g;
  $line =~ s/\t/,/g;
  return $line;
}
