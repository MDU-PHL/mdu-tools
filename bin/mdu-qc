#!/usr/bin/env perl
use strict;
use warnings;
use Cwd qw(abs_path);

#-------------------------------------------------------------------
# libraries

use Data::Dumper;
use Getopt::Long;
use FindBin;
use lib "$FindBin::RealBin/../perl5";
use MDU;
use MDU::Logger qw(msg err);

#-------------------------------------------------------------------
# command line

my $verbose = 0;
my $quiet   = 0;
my $threads = 8;
my $kmer    = 31;
my $batches = 3;
my $rootdir = $MDU::MDUDIR;
my $assembler = 'spades';

my %ok_asm = (spades=>1, velvet=>1, megahit=>1);

#-------------------------------------------------------------------

sub usage {
  my $EXE = $FindBin::RealScript;
  my $asm_opts = join(' ', keys %ok_asm);
  print <<"USAGE";
Synopsis:
  Generate a Makefile to QC all the MDU isolates
Usage: 
  $EXE [options] > Makefile
Options:
  --help	This help
  --verbose	Extra debugging output ($verbose)
  --quiet	No screen output ($quiet)
  --threads N	Threads per process ($threads)
  --kmer    K	K-mer size for assembly ($kmer)
  --batches B	Generate batch targets ($batches)
  --rootdir D   Folder where reads are contained ($rootdir)
  --asm     P   Assembler: $asm_opts ($assembler)
USAGE
  exit;
}

GetOptions(
  "help"      => \&usage,
  "verbose"   => \$verbose,
  "quiet"     => \$quiet,
  "threads=i" => \$threads,
  "rootdir=s" => \$rootdir,
  "kmer=i"    => \$kmer,
  "asm=s"     => \$assembler,
) 
or usage();

MDU::Logger->quiet($quiet);

#-------------------------------------------------------------------
# main script

exists $ok_asm{$assembler} or err("Invalid assembler '$assembler'");

$MDU::MDUDIR = abs_path( $rootdir ) if $rootdir;

msg("Analyzing", MDU->dir);
my @ID = MDU->all_ids();
my $count=0;
my %reads;

for my $name (sort @ID) {
  my $id = MDU->id($name) or err("Invalid ID: $name");
  my @reads = MDU->reads($id);
  if (@reads != 2) {
    msg("skipping $id as not looking like R1 R2:", MDU->dir($id));
    next;
  }
  msg("#$count $id @reads") if $verbose;
  $reads{$id} = [ @reads ];
  $count++;
}
msg("Found $count isolates.");


#-------------------------------------------------------------------
# construct makefile

my %make;
my $make_target = '$@';
my $make_dep = '$<';
my $make_deps = '$^';

my @id = sort keys %reads;

$make{all} = {
  DEP => \@id,
};

$make{ss} = {
  DEP => \@id,
  CMD => [
    "mdu-qc-spreadsheet > mdu-wgs.tab",
    "tsv_to_csv.pl mdu-wgs.tab > mdu-wgs.csv",
  ],
};

for my $a (keys %ok_asm) {
  $make{$a} = {
    DEP => [ map { "$_/$a.fa" } @id ],
  };
}

if ($batches > 1) {
  for my $b (1 .. $batches) {
    $make{"batch$b"} = { 
      DEP => \@id, # FIXME
    };
  }
}

for my $id (@id) 
{

  $make{$id} = {
    DEP => [ "$id/timestamp.txt", "$id/yield.tab", "$id/species.txt", "$id/mlst.tab", "$id/abricate.tab" ],
    PHONY => 1,
  };

  $make{"$id/timestamp.txt"} = {
    DEP => $reads{$id},
    CMD => [ 
      "mkdir -p '$id'",
      "date -R > $make_target",
    ]
  };

  $make{"$id/kraken.tab"} = {
    DEP => $reads{$id},
    CMD => [ 
      "mkdir -p '$id'",
      "kraken --threads $threads --preload --paired $make_deps | kraken-report > $make_target",
    ]
  };

  $make{"$id/yield.tab"} = {
    DEP => $reads{$id},
    CMD => [ 
      "mkdir -p '$id'",
      "fq $make_deps > $make_target",
    ]
  };

  $make{"$id/species.txt"} = {
    DEP => "$id/kraken.tab",
    CMD => [ 
      "grep -P \"\tS\t\" $make_dep | sort -k1nr | head -n 1 | cut -f 6 | sed 's/^ *//' > $make_target",
    ]
  };

  $make{"$id/contigs.fa"} = {
    DEP => "$id/$assembler.fa",
    CMD => "fa-add_new_ids.pl --moveid --format '$id.%05d.$assembler' $make_dep > $make_target",
  };

  my $MDIR = "$id/megahit";
  $make{"$id/megahit.fa"} = {
    DEP => $reads{$id},
    CMD => [ 
      "mkdir -p '$id'",
      "rm -fr '$MDIR'",
      "megahit --min-count 3 --k-list $kmer -t $threads --memory 0.25 -1 '$reads{$id}->[0]' -2 '$reads{$id}->[1]' --out-dir '$MDIR' --min-contig-len 500",
      "cp '$MDIR/final.contigs.fa' $make_target",
      "rm -fr '$MDIR'",
    ]
  };

  my $VDIR = "$id/velvet";
  $make{"$id/velvet.fa"} = {
    DEP => $reads{$id},
    CMD => [ 
      "mkdir -p '$id'",
      "rm -fr '$VDIR'",
      "OMP_NUM_THREADS=$threads velveth '$VDIR' $kmer -create_binary -shortPaired -fastq.gz -separate $make_deps",
      "OMP_NUM_THREADS=$threads velvetg '$VDIR' -exp_cov auto -cov_cutoff auto -min_contig_lgth 200",
      "cp '$VDIR/contigs.fa' $make_target",
      "rm -fr '$VDIR'",
    ]
  };

  my $SDIR = "$id/spades";
  $make{"$id/spades.fa"} = {
    DEP => $reads{$id},
    CMD => [ 
      "mkdir -p '$id'",
      "rm -fr '$SDIR'",
      "spades-fast --cpus $threads --gsize 4.0M --R1 '$reads{$id}->[0]' --R2 '$reads{$id}->[1]' --outdir '$SDIR'",
      "cp '$SDIR/contigs.fasta' $make_target",
      "rm -fr '$SDIR'",
    ]
  };

  $make{"$id/mlst.tab"} = {
    DEP => "$id/contigs.fa",
    CMD => [ 
      "mlst $make_dep > $make_target",
    ]
  };

  $make{"$id/abricate.tab"} = {
    DEP => "$id/contigs.fa",
    CMD => [ 
      "abricate $make_dep > $make_target",
    ]
  };

}

$make{blastdb} = {
  DEP => [ map { "$_/contigs.fa" } @id ],
  CMD => [
    "cat $make_deps | makeblastdb -title mducontigs -dbtype nucl -hash_index -out mducontigs",
  ],
};


write_makefile(\%make);

#-------------------------------------------------------------------
# write makefile

sub write_makefile {
  my($make, $fh) = @_;
  $fh = \*STDOUT if not defined $fh;

  print $fh "SHELL := /bin/bash\n";
  print $fh "MAKEFLAGS += --no-builtin-rules\n";
  print $fh "MAKEFLAGS += --no-builtin-variables\n";
  print $fh ".SUFFIXES:\n";

  for my $target ('all', sort grep { $_ ne 'all' } keys %$make) {
    print $fh "\n";
    my $rule = $make->{$target}; # short-hand
    my $dep = $rule->{DEP};
    $dep = ref($dep) eq 'ARRAY' ? (join ' ', @$dep) : $dep;
    $dep ||= '';
    print $fh ".PHONY: $target\n" if $rule->{PHONY} or ! $rule->{DEP};
    print $fh "$target: $dep\n";
    if (my $cmd = $rule->{CMD}) {
      my @cmd = ref $cmd eq 'ARRAY' ? @$cmd : ($cmd);
      print $fh map { "\t$_\n" } @cmd;
    }
  }
}
