#!/usr/bin/env perl
use strict;
use warnings;
use Cwd qw(abs_path);

#-------------------------------------------------------------------
# libraries

use Data::Dumper;
use Getopt::Long;
use FindBin;
use lib "$FindBin::RealBin/../perl5";
use MDU;
use MDU::Logger qw(msg err);

#-------------------------------------------------------------------
# globals

#my $ARIBA_DB = "$FindBin::RealBin/../db/ariba/resfinder";
my $TMPDIR = $ENV{'TMPDIR'} || '/tmp';

#-------------------------------------------------------------------
# command line

my $verbose = 0;
my $quiet   = 0;
my $threads = 8;
my $kmer    = 31;
#my $batches = 3;
my $rootdir = $MDU::MDUDIR;
my $assembler = 'shovill';   # do not change
my $scheme = 'auto';
my $tempdir = $ENV{TMPDIR} || '/tmp';
my %ok_asm = (spades=>0, velvet=>0, megahit=>0, shovill=>1);

#-------------------------------------------------------------------

sub usage {
  my $EXE = $FindBin::RealScript;
  my $asm_opts = join(' ', keys %ok_asm);
  print <<"USAGE";
Synopsis:
  Generate a Makefile to QC all the MDU isolates
Usage: 
  $EXE [options] > Makefile
Options:
  --help	This help
  --verbose	Extra debugging output ($verbose)
  --quiet	No screen output ($quiet)
  --threads N	Threads per process ($threads)
  --kmer    K	K-mer size for assembly ($kmer)
  --rootdir D   Folder where reads are contained ($rootdir)
  --asm     P   Assembler: $asm_opts ($assembler)
  --scheme  S   MLST scheme ($scheme)
  --tempdir D   Temporary working dir ($tempdir)
USAGE
  exit;
}

GetOptions(
  "help"      => \&usage,
  "verbose"   => \$verbose,
  "quiet"     => \$quiet,
  "threads=i" => \$threads,
  "rootdir=s" => \$rootdir,
  "kmer=i"    => \$kmer,
#  "asm=s"     => \$assembler,
  "scheme=s"  => \$scheme,
) 
or usage();

MDU::Logger->quiet($quiet);

#-------------------------------------------------------------------
# main script

exists $ok_asm{$assembler} or err("Invalid assembler '$assembler'");

$MDU::MDUDIR = abs_path( $rootdir ) if $rootdir;

msg("Analyzing", MDU->dir);
my @ID = MDU->all_ids();
my $count=0;
my %reads;

for my $name (sort @ID) {
  my $id = MDU->id($name) or err("Invalid ID: $name");
  my @reads = MDU->reads($id);
  if (@reads != 2) {
    msg("skipping $id as not looking like R1 R2:", MDU->dir($id));
    next;
  }
  msg("#$count $id @reads") if $verbose;
  $reads{$id} = [ @reads ];
  $count++;
}
msg("Found $count isolates.");


#-------------------------------------------------------------------
# construct makefile

my %make;
my $make_target = '$@';
my $make_dep = '$<';
my $make_deps = '$^';
my $TEMPDIR = '$(TEMPDIR)';

my $kvalues = join( q{,} , map { 31+($_*5) } (0 .. 18) );
my $mlst_opt = (!$scheme or $scheme eq 'auto') ? "" : "--scheme $scheme";

my @id = sort keys %reads;

$make{all} = {
  DEP => \@id,
  CMD => [
    "mdu-qc-spreadsheet > mdu-wgs.tab",
    "tsv_to_csv.pl mdu-wgs.tab > mdu-wgs.csv",
  ],
};

$make{ss} = {
  CMD => [
    "mdu-qc-spreadsheet > mdu-wgs.tab",
    "tsv_to_csv.pl mdu-wgs.tab > mdu-wgs.csv",
  ],
};

$make{clean} = {
  CMD => [
    'find . -type f -size 0 -delete -print',
    'find . -type d -name assembler -exec rm -frv {} \;',
  ],
};

#for my $a (keys %ok_asm) {
#  $make{$a} = {
#    DEP => [ map { "$_/$a.fa" } @id ],
#  };
#}

#if ($batches > 1) {
#  for my $b (1 .. $batches) {
#    $make{"batch$b"} = { 
#      DEP => \@id, # FIXME
#    };
#  }
#}

for my $id (@id) 
{

  $make{$id} = {
#    DEP => [ "$id/timestamp.txt", "$id/yield.tab", "$id/species.txt", "$id/mlst.tab", "$id/abricate.tab", "$id/kmerstream.tab" ],
    DEP => [ "$id/yield.tab", "$id/kraken.tab", "$id/mlst.tab", "$id/abricate.tab" ],
    PHONY => 1,
  };

  $make{"$id/kraken.tab"} = {
    DEP => $reads{$id},
    CMD => [ 
      "mkdir -p '$id'",
      "kraken --threads $threads --preload --paired $make_deps | kraken-report > $make_target",
    ]
  };

  $make{"$id/yield.tab"} = {
    DEP => $reads{$id},
    CMD => [ 
      "mkdir -p '$id'",
      "fq $make_deps > $make_target",
    ]
  };

#  $make{"$id/contigs.fa"} = {
#    DEP => "$id/$assembler.fa",
#    CMD => [
#      "fa-add_new_ids.pl --moveid --format '$id.%05d.$assembler' $make_dep > $make_target",
#      "rm -f $make_dep",
#    ],
#  };

  my $ADIR = "$id/assembler";

#  my $CMDS;
#  if ($assembler eq 'megahit') {
#    $CMDS = [ 
#      "megahit --tmp-dir $TEMPDIR --min-count 3 --k-list $kmer -t $threads --memory 0.25 -1 '$reads{$id}->[0]' -2 '$reads{$id}->[1]' --out-dir '$ADIR' --min-contig-len 500",
#      "cp '$ADIR/final.contigs.fa' $make_target",
#    ];
#  }
#  elsif ($assembler eq 'spades') {
#    $CMDS = [
#      "spades.py --cpus $threads -1 '$reads{$id}->[0]' -2 '$reads{$id}->[1]' --outdir '$ADIR' --tmpdir $TEMPDIR",
#      "cp '$ADIR/contigs.fasta' $make_target",
#    ];
#  }
#  elsif ($assembler eq 'velvet') {
#    $CMDS = [
#      "OMP_NUM_THREADS=$threads velveth '$ADIR' $kmer -create_binary -shortPaired -fastq.gz -separate $make_deps",
#      "OMP_NUM_THREADS=$threads velvetg '$ADIR' -exp_cov auto -cov_cutoff auto -min_contig_lgth 200",
#      "cp '$ADIR/contigs.fa' $make_target",
#    ];
#  }
#  elsif ($assembler eq 'shovill') {
#    $CMDS = [
#      "shovill --cpus $threads --R1 '$reads{$id}->[0]' --R2 '$reads{$id}->[1]' --outdir '$ADIR' --force",
#      "cp '$ADIR/contigs.fa' $make_target",
#    ];
#  }
#  else {
#    err("Do not know assembler '$assembler'");
#  }
  
  $make{"$id/contigs.fa"} = {
    DEP => $reads{$id},
    CMD => [
      "mkdir -p '$id'",
      "rm -fr '$ADIR'",
      "shovill --cpus $threads --R1 '$reads{$id}->[0]' --R2 '$reads{$id}->[1]' --outdir '$ADIR'",
      "fa-add_new_ids.pl --moveid --format '$id.%05d.$assembler' '$ADIR/contigs.fa' > $make_target",
      "rm -fr '$ADIR'",
    ],
  };

  $make{"$id/mlst.tab"} = {
    DEP => "$id/contigs.fa",
    CMD => [ 
      "mlst $mlst_opt $make_dep > $make_target",
    ]
  };

  $make{"$id/abricate.tab"} = {
    DEP => "$id/contigs.fa",
    CMD => [ 
      "abricate $make_dep > $make_target",
    ]
  };

#  my $ARIBA_DIR = "$id/ariba";
#  $make{"$id/ariba.tab"} = {
#    DEP => $reads{$id},
#    CMD => [ 
#      "mkdir -p '$id'",
#      "rm -fr '$ARIBA_DIR'",
#      "ariba run --tmp_dir $TMPDIR --verbose $ARIBA_DB $make_deps $ARIBA_DIR",
#      "cp '$ARIBA_DIR/report.tsv' $make_target",
##      "rm -fr '$SDIR'",
#    ]
#  };
#
#  $make{"$id/sixess/species.txt"} = {
#    DEP => $reads{$id},
#    CMD => [ 
#      "mkdir -p '$id/sixess'",
#      "/home/tseemann/git/sixess/bin/sixess -f -t $threads '$id/sixess' $make_dep",
#    ]
#  };

#  $make{"$id/kmerstream.tab"} = {
#    DEP => $reads{$id},
#    CMD => [ 
#      "mkdir -p '$id'",
#      "KmerStream --verbose -t $threads -k $kvalues --tsv --online -o /dev/stdout $make_deps ".
#        " | KmerStreamEstimate.py /dev/stdin > $make_target",
#    ]
#  };

#  $make{"$id/timestamp.txt"} = {
#    DEP => $reads{$id},
#    CMD => [ 
#      "mkdir -p '$id'",
#      "date -R > $make_target",
#    ]
#  };
#  $make{"$id/species.txt"} = {
#    DEP => "$id/kraken.tab",
#    CMD => [ 
#      "grep -P \"\tS\t\" $make_dep | sort -k1nr | head -n 1 | cut -f 6 | sed 's/^ *//' > $make_target",
#    ]
#  };

}

$make{blastdb} = {
  DEP => [ map { "$_/contigs.fa" } @id ],
  CMD => [
    "cat $make_deps | makeblastdb -title mducontigs -dbtype nucl -hash_index -out mducontigs",
  ],
};


msg("Writing Makefile");
write_makefile(\%make);
msg("Done.");

#-------------------------------------------------------------------
# write makefile

sub write_makefile {
  my($make, $fh) = @_;
  $fh = \*STDOUT if not defined $fh;

  print $fh "SHELL := /bin/bash\n";
  print $fh "MAKEFLAGS += --no-builtin-rules\n";
  print $fh "MAKEFLAGS += --no-builtin-variables\n";
  print $fh ".SUFFIXES:\n";
  print $fh "TEMPDIR := $tempdir\n";

  for my $target ('all', sort grep { $_ ne 'all' } keys %$make) {
    print $fh "\n";
    my $rule = $make->{$target}; # short-hand
    my $dep = $rule->{DEP};
    $dep = ref($dep) eq 'ARRAY' ? (join ' ', @$dep) : $dep;
    $dep ||= '';
    print $fh ".PHONY: $target\n" if $rule->{PHONY} or ! $rule->{DEP};
    print $fh "$target: $dep\n";
    if (my $cmd = $rule->{CMD}) {
      my @cmd = ref $cmd eq 'ARRAY' ? @$cmd : ($cmd);
      print $fh map { "\t$_\n" } @cmd;
    }
  }
}

